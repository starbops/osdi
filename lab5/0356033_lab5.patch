Index: nctu_os/kernel/task.c
===================================================================
--- nctu_os/kernel/task.c	(revision 369)
+++ nctu_os/kernel/task.c	(working copy)
@@ -1,6 +1,7 @@
 #include <inc/mmu.h>
 #include <inc/types.h>
 #include <inc/x86.h>
+#include <inc/lock.h>
 #include <kernel/task.h>
 
 // Global descriptor table.
@@ -93,7 +94,9 @@
 void sys_kill(int pid)
 {
 	/*Lab4 TODO: Died task recycle, just set task state as TASK_STOP and sched_yield() */
+	lock();
 	tasks[pid].state = TASK_STOP;
+	unlock();
 	sched_yield();
 
 }
@@ -112,15 +115,23 @@
 	if ((uint32_t)cur_task != NULL)
 	{
 		/* Lab4 TODO: Copy parent's tf to new task's tf */
+		lock();
 		tasks[pid].tf = cur_task->tf;
+		unlock();
 
 		/* Lab4 TODO: Copy parent's usr_stack to new task's usr_stack and reset the new task's esp pointer. */
+		lock();
 		memcpy(tasks[pid].usr_stack, cur_task->usr_stack, USR_STACK_SIZE);
+		unlock();
 		offset = (char *)cur_task->tf.tf_esp - cur_task->usr_stack;
+		lock();
 		tasks[pid].tf.tf_esp = tasks[pid].usr_stack + offset;
+		unlock();
 
 		/* Lab4 TODO: Set system call's return value, parent return 0 and child return pid. */
+		lock();
 		tasks[pid].tf.tf_regs.reg_eax = pid;
+		unlock();
 		return 0;
 	}
 
Index: nctu_os/kernel/trap.c
===================================================================
--- nctu_os/kernel/trap.c	(revision 396)
+++ nctu_os/kernel/trap.c	(working copy)
@@ -144,7 +144,7 @@
 		return;
 	}
 
-	lock();	//(1)
+	//lock();	//(1)
 	/* Lab3 TODO: Check the trap number and call the interrupt handler. */
 	if (trap_hnd[tf->tf_trapno] != NULL)
 	{
@@ -153,13 +153,15 @@
 		if ((tf->tf_cs & 3) == 3)
 		{
 			// Trapped from user mode.
+			lock();
 			cur_task->tf = *tf;
+			unlock();
 			tf = &(cur_task->tf);
 		}
 		// Do ISR
 		trap_hnd[tf->tf_trapno](tf);
 		
-		//lock();	//(2)
+		lock();	//(2)
 		env_pop_tf(tf);
 	}
 
Index: nctu_os/kernel/syscall.c
===================================================================
--- nctu_os/kernel/syscall.c	(revision 396)
+++ nctu_os/kernel/syscall.c	(working copy)
@@ -43,8 +43,10 @@
 
 	case SYS_sleep:
 		/* Lab4 TODO: set task to sleep state and yield this task. */
+		lock();
 		cur_task->state = TASK_SLEEP;
 		cur_task->remind_ticks = a1;
+		unlock();
 		sched_yield();
 		break;
 	case SYS_kill:
Index: nctu_os/kernel/timer.c
===================================================================
--- nctu_os/kernel/timer.c	(revision 369)
+++ nctu_os/kernel/timer.c	(working copy)
@@ -53,7 +53,10 @@
 		/* Lab4 TODO: Check cur_task->remind_ticks, if remind_ticks <= 0 then yield the task (call sched_yield() in sched.c)*/
 		if (cur_task->remind_ticks <= 0)
 		{
-			sched_yield();
+			if (tf->tf_cs & 3 == 3)
+			{
+				sched_yield();
+			}
 		}
 
 	}
Index: nctu_os/kernel/sched.c
===================================================================
--- nctu_os/kernel/sched.c	(revision 396)
+++ nctu_os/kernel/sched.c	(working copy)
@@ -1,4 +1,5 @@
 #include <kernel/task.h>
+#include <inc/lock.h>
 
 static index = 0;
 void sched_yield(void)
@@ -19,31 +20,36 @@
 		{
 			if (cur_task->state == TASK_RUNNING)
 			{
+				lock();
 				cur_task->state = TASK_RUNNABLE;
 				cur_task->remind_ticks = TIME_QUANT;
 				cur_task = &tasks[i];
 				tasks[i].state = TASK_RUNNING;
+				unlock();
 				break;
 			} else if (cur_task->state == TASK_SLEEP)
 			{
+				lock();
 				cur_task = &tasks[i];
 				tasks[i].state = TASK_RUNNING;
+				unlock();
 				break;
 			} else if (cur_task->state == TASK_STOP) {
+				lock();
 				cur_task = &tasks[i];
 				tasks[i].state = TASK_RUNNING;
+				unlock();
 				break;
 			}
 		} else if ( tasks[i].state == TASK_RUNNING)
 		{
-			//cur_task = &tasks[i];
+			lock();
 			tasks[i].remind_ticks = TIME_QUANT;
+			unlock();
 		}
 		i = (i + 1) % NR_TASKS;
 	}
 
-	if (next_i != NR_TASKS)
-	{
-		env_pop_tf(&cur_task->tf);
-	}
+	lock();
+	env_pop_tf(&cur_task->tf);
 }
